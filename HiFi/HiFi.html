<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Timerange</title>
    <style>

        body {
            display: flex;
            justify-content: center;
            align-content: center;

        }

        .UI {
            display: flex;
            flex-direction: column;
        }

        .Input {
            display: flex;
            justify-content: center;
            align-content: center;
            padding: 2em;
        }
        #angleInput{
            display:none
        }

        .world {
            width: 300px;
            height: 300px;
            border-radius: 50%;
            position: relative;
            /*overflow: hidden;*/
            /*background-color: lightblue;*/
            background: url("img/globelight.png");
            background-size: cover;
            border: black solid 2px;
        }

        .hour-mark {
            position: absolute;
            width: 2px;
            height: 20px;
            background-color: black;
            transform-origin: 0 0px; /* Das Zentrum des Kreises */
            left: 50%;
            top: 50%;
        }


        .slice {
            position: absolute;
            inset: 0;
            background: rgba(252, 196, 78, 0.5);
            clip-path: polygon(50% 50%, 50% 50%, 50% 50%); /* Start ohne Sichtbarkeit bei 0 grad */
            /*transform:rotate(45deg);*/
            cursor: pointer;
        }

        .icon-grab {
            position: absolute;
            width: 20px;
            height: 20px;
            background: url("img/grab.png") no-repeat center center;
            background-size: contain;
            display: none;
            justify-content: center;
            align-items: center;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Stellt sicher, dass das Hover über den Slice und nicht über das Icon selbst erkannt wird => verhindert flackern*/
            cursonr: pointer;
        }

        .icon-grab:hover {
            cursor: pointer;
        }
        .slice:hover .icon-grab {
            display: block; /* oder 'flex', je nach Bedarf */
        }

    </style>
</head>
<body>
<div class="UI">
    <div class="Input">
       <input type="number" id="angleInput" placeholder="Grad (0-360 Grad)" min="0" max="360" style="width: 8rem;"/>
        <p>Duration:  </p>
        <input type="time" id="timeInput" placeholder="Zeit (HH:MM)" style="width: 8rem; margin-top: 1em;"/>
    </div>
    <div class="start_end">
        <p>Start: <span id="startTime">00:00</span></p>
    </div>
    <div class="start_end">
        <p>End: <span id="endTime">00:00</span></p>
    </div>


    <div class="world">
        <div class="slice"></div>
        <div class="icon-grab"></div>
    </div>



</div>

<script>
    // pro Stunde eine Markierung
    const clock = document.querySelector('.world');
    for (let i = 0; i < 24; i++) {
        let mark = document.createElement('div');
        mark.className = 'hour-mark';
        // Berechnet den Winkel und setzt die Rotation
        let angle = i * 15;
        mark.style.transform = `rotate(${angle}deg) translateY(-150px)`;
        clock.appendChild(mark);
    }

    // angle input-------------------------------------
    document.getElementById('angleInput').addEventListener('input', function () {
        const angle = Math.min(Math.max(0, this.value), 360); // Begrenzt die Eingabe auf Werte zwischen 0 und 360
        const slice = document.querySelector('.slice');

        if (angle <= 0) {
            slice.style.opacity = 0; // Unsichtbar machen, wenn der Winkel 0 ist
        } else {
            const slicePercentage = angle / 360;
            slice.style.opacity = 1; // Sorgt dafür, dass das Kuchenstück sichtbar ist

            // Berechnet den Clip-Pfad abhängig vom Winkel
            slice.style.clipPath = `polygon(50% 50%, ${calculateClipPath(angle)})`;
        }
    });
    //----------------------------------------------------------

    //time input --------------------------------------------
    document.getElementById('timeInput').addEventListener('change', function (e) {
        const [hours, minutes] = e.target.value.split(':').map(num => parseInt(num, 10));
        // Es ist möglich, dass keine gültige Zeit eingegeben wurde, also prüfen wir auf NaN (Not a Number).
        if (!isNaN(hours) && !isNaN(minutes)) {
            const totalDegrees = hours * 15 + minutes * 0.25;
            updateSlice(totalDegrees);
            updateIconPosition(totalDegrees);
        }
    });

    //----------------------------------------

    function updateSlice(angle) {
        const slice = document.querySelector('.slice');
        if (angle <= 0) {
            slice.style.opacity = 0; // Unsichtbar machen, wenn der Winkel 0 ist
        } else {
            slice.style.opacity = 1; // Sorgt dafür, dass das Kuchenstück sichtbar ist
            // Berechnet den Clip-Pfad abhängig vom Winkel
            slice.style.clipPath = `polygon(50% 50%, ${calculateClipPath(angle)})`;
        }
    }

    //binded die input felder------------------------------------------------------------------------
    document.getElementById('angleInput').addEventListener('input', updateFromInputs);
    document.getElementById('timeInput').addEventListener('change', function () {
        const [hours, minutes] = this.value.split(':').map(num => parseInt(num, 10));
        const angle = hours * 15 + minutes * 0.25;
        document.getElementById('angleInput').value = angle; // Aktualisiert den Winkel basierend auf der Zeit
        updateFromInputs();
        updateIconPosition(angle); // Diese Zeile hinzufügen
    });


    function updateFromInputs() {
        const angle = parseFloat(document.getElementById('angleInput').value) || 0;
        updateSlice(angle);
        updateIconPosition(angle);

        // Aktualisiert das Zeitfeld basierend auf dem Winkel.
        const hours = Math.floor(angle / 15);
        const minutes = Math.floor((angle % 15) * 4);
        document.getElementById('timeInput').value = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }
    //--------------------------------------------------------------------------

    //berechnet den clippath für das slice---------------------------------------

    /*  Die calculateClipPath Funktion berechnet den Pfad für das Polygon, das den Clip-Path für das Kuchenstück bildet.

        steps gibt an, wie viele Punkte entlang des Bogens berechnet werden, um eine glatte Kurve zu erzeugen. (umso mehr => umso glatter aber umso rechenintensiver.)

        Innerhalb der for-Schleife:
        theta ist der Winkel in Grad für jeden dieser Schritte des Bogens, beginnend bei -90 Grad (das ist der Startpunkt oben auf dem Kreis).
        x und y sind die Koordinaten jedes Punktes auf dem Bogen, berechnet mit der Kosinus- und Sinusfunktion.

        Nach der Schleife wird der letzte Punkt hinzugefügt, um das Polygon zu schließen, indem wieder auf das Zentrum des Kreises gezeigt wird.
        Die Funktion gibt dann diesen Pfad als Zeichenkette zurück, die in der clip-path-Eigenschaft des Kuchenstücks verwendet wird.*/

    function calculateClipPath(angle) {
        let path = "";
        const steps = 100; // Anzahl der Schritte für den Bogen. wichtig damit das kuchenstück bis zum umfang des kresises ausgefüllt wird.
        const centerX = 50; // Zentrum des Kreises in Prozent
        const centerY = 50; // Zentrum des Kreises in Prozent

        for (let step = 0; step <= steps; step++) {
            const theta = (angle / steps) * step - 90; // Startet bei -90 Grad, um oben auf dem Kreis zu beginnen
            const x = centerX + 50 * Math.cos((Math.PI * theta) / 180);
            const y = centerY + 50 * Math.sin((Math.PI * theta) / 180);
            path += `${x}% ${y}%, `;
        }

        // Fügt den Anfangspunkt hinzu, um das Polygon zu schließen
        path += `50% 50%`;
        console.log(path);
        return path;
    }

    //grab icon anzeigen---------------------------------------
    const slice = document.querySelector('.slice');
    const iconGrab = document.querySelector('.icon-grab'); // Referenz zum Icon-Element

    // Zeigt das Icon, wenn cursor über das Slice kommt
    slice.addEventListener('mouseenter', () => {
        iconGrab.style.display = 'flex';
    });

    // Versteckt das Icon, wenn die Maus das Slice verlässt
    slice.addEventListener('mouseleave', () => {
        iconGrab.style.display = 'none';
    });

    function updateIconPosition(angle) {
        // Der Winkel, der für die Positionierung des Icons verwendet wird, sollte der Mittelwert des Slices sein.
        const middleAngle = angle /2;

        // Umrechnung des mittleren Winkels von Grad in Bogenmaß
        const radian = (middleAngle - 90) * (Math.PI / 180);

        // Berechnet die x- und y-Position innerhalb des Slices
        const radius = clock.offsetWidth / 2; // Verwende den Radius des Kreises
        const iconRadius = radius * 0.6; // Setze das Icon etwas innerhalb des Randes, hier bei 50% des Radius

        // Berechnet die x- und y-Koordinaten für das Icon
        const iconX = (clock.offsetWidth / 2) + iconRadius * Math.cos(radian);
        const iconY = (clock.offsetHeight / 2) + iconRadius * Math.sin(radian);

        // Aktualisiere die Position des Icons
        iconGrab.style.left = `${iconX}px`;
        iconGrab.style.top = `${iconY}px`;
        iconGrab.style.transform = 'translate(-50%, -50%)';
    }
    //--------------------------------------------------------------


    //start und endzeit updaten---------------------------------------
    function updateFromInputs() {
        const angle = parseFloat(document.getElementById('angleInput').value) || 0;

        // Berechnet die Endzeit basierend auf dem Startwinkel und der Dauer
        const startTotalMinutes = 0; // Startzeit ist 00:00, also 0 Minuten nach Mitternacht
        const durationMinutes = angle / 360 * 1440; // Umwandlung des Winkels in Minuten (360 Grad entsprechen 1440 Minuten, also einem ganzen Tag)
        const endTotalMinutes = startTotalMinutes + durationMinutes;

        const startHours = Math.floor(startTotalMinutes / 60);
        const startMinutes = startTotalMinutes % 60;
        const endHours = Math.floor(endTotalMinutes / 60) % 24; // Verwendet Modulo 24, um sicherzustellen, dass die Stunden nicht über 24 hinausgehen
        const endMinutes = endTotalMinutes % 60;

        // Aktualisiert die Anzeige der Start- und Endzeiten
        document.getElementById('startTime').textContent = `${startHours.toString().padStart(2, '0')}:${startMinutes.toString().padStart(2, '0')}`;
        document.getElementById('endTime').textContent = `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;

        // Aktualisiert das Zeitfeld basierend auf dem Winkel.
        document.getElementById('timeInput').value = `${endHours.toString().padStart(2, '0')}:${endMinutes.toString().padStart(2, '0')}`;
        updateSlice(angle);
        updateIconPosition(angle);
    }
//-------------------------------------------------------------------------
</script>

</body>
</html>
